name: Build pcsx_rearmed for Dingux (mips32) (No GPU)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Install build dependencies
        run: |
          sudo apt update && sudo apt install -y \
            git \
            build-essential \
            gcc-mipsel-linux-gnu \
            g++-mipsel-linux-gnu \
            libtool \
            autoconf \
            automake \
            pkg-config \
            make \
            cmake \
            python3 \
            wget \
            unzip

      - name: Clone pcsx_rearmed source directly (skip libretro-super script dependency)
        run: |
          # 直接克隆源码，避免libretro-super的子模块/脚本问题
          git clone https://github.com/libretro/pcsx_rearmed.git
          cd pcsx_rearmed
          # 确保源码完整（拉取所有分支/标签）
          git fetch --all
          # 打印源码目录结构，确认Makefile存在
          echo "===== pcsx_rearmed源码目录结构 ====="
          ls -la
          echo "===== 确认Makefile是否存在 ====="
          if [ -f "Makefile" ]; then
            echo "✅ Makefile存在"
            # 查看Makefile中关键编译配置
            grep -E "(CC|LD|mips|DINGUX|SOFTWARE|GPU|GL)" Makefile || true
          else
            echo "❌ Makefile不存在"
            exit 1
          fi

      - name: Set cross-compile env for Dingux mips32 (No GPU)
        run: |
          # 核心：无GPU编译环境变量，精简且明确
          echo "CC=mipsel-linux-gnu-gcc" >> $GITHUB_ENV
          echo "CXX=mipsel-linux-gnu-g++" >> $GITHUB_ENV
          echo "AR=mipsel-linux-gnu-ar" >> $GITHUB_ENV
          echo "RANLIB=mipsel-linux-gnu-ranlib" >> $GITHUB_ENV
          echo "STRIP=mipsel-linux-gnu-strip" >> $GITHUB_ENV
          # 适配mips32 + 无GPU + Dingux的编译参数
          echo "CFLAGS=-march=mips32 -mabi=32 -mtune=mips32 -O2 -fPIC -DDINGUX=1 \
            -DNO_GPU=1 -DNO_OPENGL=1 -DNO_GLES=1 -DNO_GLES2=1 -DUSE_SOFTWARE_RENDERER=1 \
            -DLIBRETRO=1 -DNDEBUG" >> $GITHUB_ENV
          echo "CXXFLAGS=${{ env.CFLAGS }}" >> $GITHUB_ENV
          echo "LDFLAGS=-march=mips32 -mabi=32 -mtune=mips32 -fPIC -shared -lm" >> $GITHUB_ENV
          # 打印环境变量确认
          echo "===== 编译环境变量 ====="
          env | grep -E "(CC|CXX|CFLAGS|DINGUX|NO_GPU|SOFTWARE)"

      - name: Manual build pcsx_rearmed (skip libretro-super script)
        run: |
          cd pcsx_rearmed
          # 手动清理旧编译产物
          make clean || echo "无旧产物需要清理"
          # 核心：手动指定编译参数，直接编译libretro核心
          echo "===== 开始手动编译 ====="
          make -j$(nproc) \
            CC=${{ env.CC }} \
            CXX=${{ env.CXX }} \
            AR=${{ env.AR }} \
            RANLIB=${{ env.RANLIB }} \
            STRIP=${{ env.STRIP }} \
            CFLAGS="${{ env.CFLAGS }}" \
            CXXFLAGS="${{ env.CXXFLAGS }}" \
            LDFLAGS="${{ env.LDFLAGS }}" \
            platform=libretro \
            USE_SOFTWARE_RENDERER=1 \
            DISABLE_GPU=1 \
            VERBOSE=1
          
          # 详细排查：打印编译日志后，查找所有生成的文件
          echo "===== 编译后目录文件 ====="
          ls -la
          echo "===== 查找.so文件 ====="
          find . -name "*.so" -type f -ls
          echo "===== 查找.a/.o文件（确认编译是否有产物） ====="
          find . -name "*.a" -o -name "*.o" | head -20

      - name: Verify build output and copy to fixed path
        run: |
          # 确认.so文件存在，否则终止流程
          if [ -f "pcsx_rearmed/pcsx_rearmed_libretro.so" ]; then
            echo "✅ 编译成功，找到目标文件"
            # 复制到固定路径，方便上传
            mkdir -p ./build_output
            cp pcsx_rearmed/pcsx_rearmed_libretro.so ./build_output/
            # 验证文件架构（确认是mips32）
            file ./build_output/pcsx_rearmed_libretro.so
          else
            echo "❌ 编译失败，未找到pcsx_rearmed_libretro.so"
            # 打印更多排查信息
            echo "===== 最后尝试查找所有可能的产物 ====="
            find . -name "*pcsx*libretro*" -type f
            exit 1
          fi

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: pcsx_rearmed-dingux-mips32-no-gpu
          path: ./build_output/pcsx_rearmed_libretro.so
          retention-days: 30
          if-no-files-found: error # 找不到文件直接报错，便于排查
