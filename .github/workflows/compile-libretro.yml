name: Build pcsx_rearmed libretro core for GKD pixel

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths-ignore: [ '**.md', 'LICENSE' ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout base tools
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install system dependencies
        run: |
          sudo apt update && sudo apt install -y \
            wget tar make gcc g++ unzip pkg-config git patch

      - name: Download and extract GKD pixel toolchain
        run: |
          mkdir -p ~/toolchain
          wget -q https://github.com/game-de-it/GKD_pixel/releases/download/GKDpixel-toolchain-v1/mipsel-gcw0-linux-uclibc_sdk-buildroot.tar.gz -O ~/toolchain/toolchain.tar.gz
          tar -xf ~/toolchain/toolchain.tar.gz -C ~/toolchain --strip-components=1
          # 验证工具链sysroot
          SYSROOT=$(~/toolchain/bin/mipsel-gcw0-linux-uclibc-gcc -print-sysroot)
          echo "SYSROOT=$SYSROOT" >> $GITHUB_ENV
          if [ ! -d $SYSROOT/usr/include ]; then
            echo "❌ Toolchain sysroot missing!"
            exit 1
          fi

      - name: Configure cross-compile environment
        run: |
          # 添加工具链到PATH
          echo "$HOME/toolchain/bin" >> $GITHUB_PATH
          # 核心编译变量（补充所有必要头文件路径和宏）
          echo "CROSS=mipsel-gcw0-linux-uclibc-" >> $GITHUB_ENV
          echo "CFLAGS=-mips32r2 -mtune=mips32r2 -mhard-float -ffast-math -O2 -fPIC \
            -I$HOME/pcsx_rearmed \
            -I$HOME/pcsx_rearmed/libpcsxcore \
            -I${{ env.SYSROOT }}/usr/include \
            -DMAXPATHLEN=4096 \
            -DCALLBACK= \
            -D__unix__=1" >> $GITHUB_ENV # 定义CALLBACK为空，解决调用约定报错
          echo "CXXFLAGS=${{ env.CFLAGS }}" >> $GITHUB_ENV
          echo "LDFLAGS=-L${{ env.SYSROOT }}/usr/lib -L$HOME/toolchain/lib -lm -lpthread -ldl -fPIC -shared" >> $GITHUB_ENV

      - name: Clone pcsx_rearmed source code and fix missing files
        run: |
          git clone --depth 1 https://github.com/libretro/pcsx_rearmed.git ~/pcsx_rearmed
          cd ~/pcsx_rearmed
          
          # ========== 修复1：完善config.h（解决CALLBACK/MAXPATHLEN） ==========
          cat > config.h << 'EOF'
          #define PACKAGE_VERSION "1.0"
          #define HAVE_STDINT_H 1
          #define HAVE_INTTYPES_H 1
          #define HAVE_STRUCT_TIMESPEC 1
          #define HAVE_PTHREAD_H 1
          #define HAVE_DLFCN_H 1
          #define HAVE_SYS_PARAM_H 1
          #define HAVE_STDIO_H 1
          #define DYNAREC "lightrec"
          #define BUILTIN_GPU "peops"
          #define __LIBRETRO__ 1
          #undef USE_SDL
          #undef USE_ALSA
          #undef USE_PULSEAUDIO
          #define ARCH_MIPS 1
          #define MAXPATHLEN 4096
          #define CALLBACK /* Linux下调用约定为空 */
          typedef unsigned int uint32_t;
          typedef int int32_t;
          typedef unsigned short uint16_t;
          typedef short int16_t;
          typedef unsigned char uint8_t;
          typedef char int8_t;
          EOF

          # ========== 修复2：完善psemu_plugin_defs.h（补充所有缺失类型） ==========
          cat > libpcsxcore/psemu_plugin_defs.h << 'EOF'
          #ifndef PSEMU_PLUGIN_DEFS_H
          #define PSEMU_PLUGIN_DEFS_H

          #define CALLBACK /* 兼容源码中的CALLBACK宏 */
          #define PSX_PLUGIN_API_VERSION 1

          // 基础类型定义
          typedef unsigned char u8;
          typedef unsigned short u16;
          typedef unsigned int u32;
          typedef signed char s8;
          typedef signed short s16;
          typedef signed int s32;
          typedef float f32;
          typedef double f64;
          typedef unsigned int uint32_t;
          typedef int int32_t;
          typedef unsigned short uint16_t;
          typedef short int16_t;
          typedef unsigned char uint8_t;
          typedef char int8_t;

          // 插件类型枚举
          typedef enum {
              PLUGIN_TYPE_GPU,
              PLUGIN_TYPE_SPU,
              PLUGIN_TYPE_CDROM,
              PLUGIN_TYPE_PAD,
              PLUGIN_TYPE_DEV9
          } PluginType;

          // 缺失的结构体定义（极简版，仅满足编译）
          typedef struct {
              int dummy;
          } GPUFreeze_t, xa_decode_t, PadDataS;

          // 兼容函数指针定义
          typedef long (CALLBACK *GPUopen)(unsigned long *, char *, char *);
          typedef long (CALLBACK *SPUopen)(void);
          typedef long (CALLBACK *SIO1open)(unsigned long *);
          void CALLBACK SPUirq(int cycles_after);
          void CALLBACK SPUschedule(unsigned int cycles_after);
          typedef unsigned long (CALLBACK* PSEgetLibType)(void);
          typedef unsigned long (CALLBACK* PSEgetLibVersion)(void);
          typedef char *(CALLBACK* PSEgetLibName)(void);
          typedef long (CALLBACK* GPUinit)(void);
          typedef long (CALLBACK* GPUshutdown)(void);
          typedef long (CALLBACK* GPUclose)(void);
          typedef void (CALLBACK* GPUwriteStatus)(uint32_t);
          typedef void (CALLBACK* GPUwriteData)(uint32_t);
          typedef void (CALLBACK* GPUwriteDataMem)(uint32_t *, int);
          typedef uint32_t (CALLBACK* GPUreadStatus)(void);
          typedef uint32_t (CALLBACK* GPUreadData)(void);
          typedef void (CALLBACK* GPUreadDataMem)(uint32_t *, int);
          typedef long (CALLBACK* GPUdmaChain)(uint32_t *, uint32_t, uint32_t *, int32_t *);
          typedef void (CALLBACK* GPUupdateLace)(void);
          typedef long (CALLBACK* GPUfreeze)(uint32_t, GPUFreeze_t *);
          typedef void (CALLBACK* GPUvBlank)(int, int);
          typedef void (CALLBACK* GPUgetScreenInfo)(int *, int *);
          typedef long (CALLBACK* SPUinit)(void);
          typedef long (CALLBACK* SPUshutdown)(void);
          typedef long (CALLBACK* SPUclose)(void);
          typedef void (CALLBACK* SPUwriteRegister)(unsigned long, unsigned short, unsigned int);
          typedef unsigned short (CALLBACK* SPUreadRegister)(unsigned long, unsigned int);
          typedef void (CALLBACK* SPUwriteDMAMem)(unsigned short *, int, unsigned int);
          typedef void (CALLBACK* SPUreadDMAMem)(unsigned short *, int, unsigned int);
          typedef void (CALLBACK* SPUplayADPCMchannel)(xa_decode_t *, unsigned int, int);
          typedef void (CALLBACK* SPUregisterCallback)(void (CALLBACK *callback)(int));
          typedef void (CALLBACK* SPUregisterScheduleCb)(void (CALLBACK *callback)(unsigned int cycles_after));
          typedef long (CALLBACK* SPUfreeze)(unsigned int, struct SPUFreeze *, unsigned int);
          typedef void (CALLBACK* SPUasync)(unsigned int, unsigned int);
          typedef int  (CALLBACK* SPUplayCDDAchannel)(short *, int, unsigned int, int);
          typedef void (CALLBACK* SPUsetCDvol)(unsigned char, unsigned char, unsigned char, unsigned char, unsigned int);

          // 外部函数声明（极简版）
          extern GPUupdateLace    GPU_updateLace;
          extern GPUinit          GPU_init;
          extern GPUshutdown      GPU_shutdown;
          extern GPUopen          GPU_open;
          extern GPUclose         GPU_close;
          extern GPUreadStatus    GPU_readStatus;
          extern GPUreadData      GPU_readData;
          extern GPUreadDataMem   GPU_readDataMem;
          extern GPUwriteStatus   GPU_writeStatus;
          extern GPUwriteData     GPU_writeData;
          extern GPUwriteDataMem  GPU_writeDataMem;
          extern GPUdmaChain      GPU_dmaChain;
          extern GPUfreeze        GPU_freeze;
          extern GPUvBlank        GPU_vBlank;
          extern GPUgetScreenInfo GPU_getScreenInfo;
          extern SPUinit             SPU_init;
          extern SPUshutdown         SPU_shutdown;
          extern SPUopen             SPU_open;
          extern SPUclose            SPU_close;
          extern SPUwriteRegister    SPU_writeRegister;
          extern SPUreadRegister     SPU_readRegister;
          extern SPUwriteDMAMem      SPU_writeDMAMem;
          extern SPUreadDMAMem       SPU_readDMAMem;
          extern SPUplayADPCMchannel SPU_playADPCMchannel;
          extern SPUfreeze           SPU_freeze;
          extern SPUregisterCallback SPU_registerCallback;
          extern SPUregisterScheduleCb SPU_registerScheduleCb;
          extern SPUasync            SPU_async;
          extern SPUplayCDDAchannel  SPU_playCDDAchannel;
          extern SPUsetCDvol         SPU_setCDvol;
          long PAD1_readPort(PadDataS *);
          long PAD2_readPort(PadDataS *);

          #endif // PSEMU_PLUGIN_DEFS_H
          EOF

          # ========== 修复3：给cdriso.c添加缺失的<stdio.h>头文件 ==========
          sed -i '1i #include <stdio.h>' libpcsxcore/cdriso.c
          # 验证修改
          head -5 libpcsxcore/cdriso.c

          # ========== 验证所有修复文件 ==========
          echo "✅ Fixed files list:"
          ls -la config.h libpcsxcore/psemu_plugin_defs.h
          grep -c "#include <stdio.h>" libpcsxcore/cdriso.c

      - name: Build pcsx_rearmed libretro core
        run: |
          cd ~/pcsx_rearmed
          # 单线程编译（嵌入式工具链推荐）
          make -f Makefile.libretro \
            CC=${{ env.CROSS }}gcc \
            CXX=${{ env.CROSS }}g++ \
            AR=${{ env.CROSS }}ar \
            RANLIB=${{ env.CROSS }}ranlib \
            CFLAGS="${{ env.CFLAGS }}" \
            CXXFLAGS="${{ env.CXXFLAGS }}" \
            LDFLAGS="${{ env.LDFLAGS }}" \
            PLATFORM=unix \
            ARCH=mips \
            -j1
          # 验证产物
          if [ -f pcsx_rearmed_libretro.so ]; then
            echo "✅ Build success! Final core info:"
            file pcsx_rearmed_libretro.so
            du -h pcsx_rearmed_libretro.so
          else
            echo "❌ Build failed! No core file generated."
            exit 1
          fi

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: pcsx_rearmed-gkd-pixel
          path: ~/pcsx_rearmed/pcsx_rearmed_libretro.so
          retention-days: 30
